# ナレッジグラフ機能実装計画書

## 1. 概要

既存の専門用語辞書とクラスタリング結果を活用し、専門知識の関係性を可視化・活用するナレッジグラフシステムを構築する。

## 2. 目的

- 専門用語間の意味的関係を明示的に表現
- クエリ拡張による検索精度の向上
- 知識の階層構造の可視化
- 推論による新たな知識発見

## 3. スキーマ設計

### 3.1 ノードタイプ

| タイプ | 説明 | 例 |
|--------|------|-----|
| Term | 専門用語 | ピストン、ターボチャージャー |
| Category | カテゴリ（クラスタ） | エンジン部品、排ガス制御 |
| Domain | ドメイン（分野） | 舶用機関、環境規制 |
| Component | 構成要素 | 部品、サブシステム |
| System | システム全体 | エンジンシステム、推進システム |

### 3.2 ノードプロパティ

```json
{
  "TermNode": {
    "id": "UUID",
    "term": "専門用語名",
    "definition": "定義",
    "aliases": ["同義語リスト"],
    "importance_score": "C-value等の重要度",
    "embedding": "1536次元ベクトル",
    "lambda_value": "階層での具体性（HDBSCAN）",
    "depth": "階層の深さ",
    "source_documents": ["ソース文書ID"],
    "created_at": "作成日時",
    "updated_at": "更新日時"
  },
  "CategoryNode": {
    "id": "UUID",
    "name": "カテゴリ名",
    "level": "上位/中間/具体",
    "cluster_id": "クラスタID",
    "member_count": "メンバー数"
  }
}
```

### 3.3 エッジタイプ

| 関係タイプ | 説明 | 例 |
|------------|------|-----|
| **階層関係** |
| IS_A | 〜の一種である | ピストン IS_A エンジン部品 |
| HAS_SUBTYPE | 下位分類を持つ | エンジン HAS_SUBTYPE レシプロエンジン |
| **構成関係** |
| PART_OF | 〜の一部である | ピストン PART_OF エンジン |
| HAS_COMPONENT | 構成要素を持つ | エンジン HAS_COMPONENT ピストン |
| INCLUDES | 含む/包含する | システム INCLUDES サブシステム |
| **機能関係** |
| USED_FOR | 〜に使用される | ターボチャージャー USED_FOR 過給 |
| PERFORMS | 〜を実行する | SCRシステム PERFORMS NOx還元 |
| CONTROLS | 〜を制御する | ガバナ CONTROLS エンジン回転数 |
| MEASURES | 〜を測定する | センサー MEASURES 圧力 |
| **関連関係** |
| RELATED_TO | 関連する | EGR RELATED_TO NOx削減 |
| SIMILAR_TO | 類似する | ディーゼル SIMILAR_TO 圧縮着火 |
| CO_OCCURS_WITH | 共起する | ピストン CO_OCCURS_WITH シリンダ |
| DEPENDS_ON | 依存する | 燃焼 DEPENDS_ON 空燃比 |
| **プロセス関係** |
| CAUSES | 引き起こす | ノッキング CAUSES エンジン損傷 |
| PREVENTS | 防止する | インタークーラー PREVENTS 過熱 |
| PROCESSES | 処理する | 清浄機 PROCESSES 燃料油 |
| GENERATES | 生成する | エンジン GENERATES 動力 |

### 3.4 エッジプロパティ

```json
{
  "Edge": {
    "type": "関係タイプ",
    "weight": "関係の強さ (0-1)",
    "confidence": "信頼度 (0-1)",
    "source": "抽出元 (clustering/llm/manual/definition)",
    "evidence": ["根拠となる文書・文"],
    "created_at": "作成日時"
  }
}
```

## 4. データベース設計

### 4.1 PostgreSQL スキーマ

```sql
-- ノードテーブル
CREATE TABLE knowledge_nodes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    node_type VARCHAR(50) NOT NULL,
    term VARCHAR(255) UNIQUE,
    definition TEXT,
    properties JSONB,
    embedding vector(1536),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- エッジテーブル
CREATE TABLE knowledge_edges (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    source_id UUID REFERENCES knowledge_nodes(id) ON DELETE CASCADE,
    target_id UUID REFERENCES knowledge_nodes(id) ON DELETE CASCADE,
    edge_type VARCHAR(50) NOT NULL,
    weight FLOAT DEFAULT 1.0,
    confidence FLOAT DEFAULT 1.0,
    properties JSONB,
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(source_id, target_id, edge_type)
);

-- インデックス
CREATE INDEX idx_nodes_type ON knowledge_nodes(node_type);
CREATE INDEX idx_nodes_term ON knowledge_nodes(term);
CREATE INDEX idx_nodes_properties ON knowledge_nodes USING GIN(properties);
CREATE INDEX idx_edges_source ON knowledge_edges(source_id);
CREATE INDEX idx_edges_target ON knowledge_edges(target_id);
CREATE INDEX idx_edges_type ON knowledge_edges(edge_type);
CREATE INDEX idx_edges_weight ON knowledge_edges(weight DESC);
```

## 5. 自動関係抽出戦略

### 5.1 クラスタリング結果からの抽出

```python
def extract_from_clustering(clustering_results):
    relations = []
    
    # 1. λ値の差から階層関係を判定
    for term1, term2 in term_pairs:
        if term1.lambda_value - term2.lambda_value > threshold:
            relations.append({
                "source": term2,
                "target": term1,
                "type": "IS_A",
                "weight": calculate_weight(lambda_diff)
            })
    
    # 2. 同一クラスタ内の類似関係
    for cluster in clusters:
        for term1, term2 in combinations(cluster.terms, 2):
            relations.append({
                "source": term1,
                "target": term2,
                "type": "SIMILAR_TO",
                "weight": cosine_similarity(term1.embedding, term2.embedding)
            })
    
    return relations
```

### 5.2 定義文からの関係抽出

```python
# パターンマッチングによる関係抽出
RELATION_PATTERNS = {
    r"(.+)の一種": ("IS_A", 0.9),
    r"(.+)を含む": ("INCLUDES", 0.8),
    r"(.+)に使用": ("USED_FOR", 0.85),
    r"(.+)を制御": ("CONTROLS", 0.9),
    r"(.+)の部品": ("PART_OF", 0.95),
    r"(.+)を測定": ("MEASURES", 0.9),
    r"(.+)を防止": ("PREVENTS", 0.85),
    r"(.+)を処理": ("PROCESSES", 0.8),
    r"(.+)から構成": ("HAS_COMPONENT", 0.9)
}

def extract_from_definitions(terms):
    relations = []
    for term in terms:
        for pattern, (rel_type, confidence) in RELATION_PATTERNS.items():
            matches = re.findall(pattern, term.definition)
            for match in matches:
                target = find_term(match)
                if target:
                    relations.append({
                        "source": term,
                        "target": target,
                        "type": rel_type,
                        "confidence": confidence
                    })
    return relations
```

### 5.3 共起関係からの抽出

```python
def extract_cooccurrence(documents):
    cooccurrence_matrix = build_cooccurrence_matrix(documents)
    relations = []
    
    for term1, term2 in high_cooccurrence_pairs(cooccurrence_matrix):
        relations.append({
            "source": term1,
            "target": term2,
            "type": "CO_OCCURS_WITH",
            "weight": normalized_pmi(term1, term2)
        })
    
    return relations
```

## 6. 実装計画

### Phase 1: 基盤構築（1週間）
- [ ] データベーススキーマの作成
- [ ] 基本的なCRUD操作の実装
- [ ] 既存データの移行スクリプト

### Phase 2: 関係抽出（2週間）
- [ ] クラスタリング結果からの関係抽出
- [ ] 定義文パターンマッチングの実装
- [ ] 共起関係の計算
- [ ] LLMによる関係抽出（オプション）

### Phase 3: グラフ操作（1週間）
- [ ] グラフトラバーサルの実装
- [ ] 最短経路探索
- [ ] コミュニティ検出
- [ ] 中心性分析

### Phase 4: 可視化（1週間）
- [ ] NetworkXによるグラフ構造の構築
- [ ] Pyvisによるインタラクティブ可視化
- [ ] Streamlit UIへの統合

### Phase 5: 活用機能（2週間）
- [ ] クエリ拡張機能の実装
- [ ] 推論による新規関係の発見
- [ ] 知識の一貫性チェック
- [ ] APIエンドポイントの作成

## 7. 活用例

### 7.1 クエリ拡張

```python
def expand_query_with_knowledge_graph(query_term):
    expanded_terms = set([query_term])
    
    # IS_A関係で上位概念を追加
    broader_terms = graph.get_broader_terms(query_term, max_depth=2)
    expanded_terms.update(broader_terms)
    
    # PART_OF関係で全体概念を追加
    whole_terms = graph.get_whole_terms(query_term)
    expanded_terms.update(whole_terms)
    
    # SIMILAR_TO関係で類似語を追加
    similar_terms = graph.get_similar_terms(query_term, min_weight=0.7)
    expanded_terms.update(similar_terms)
    
    # RELATED_TO関係で関連語を追加（重み付き）
    related_terms = graph.get_related_terms(query_term, min_weight=0.6)
    for term, weight in related_terms:
        expanded_terms.add((term, weight * 0.5))  # 減衰係数適用
    
    return expanded_terms
```

### 7.2 知識推論

```python
def infer_new_relations(graph):
    new_relations = []
    
    # 推移律による推論
    # A IS_A B かつ B IS_A C なら A IS_A C
    for a, b in graph.get_edges(type="IS_A"):
        for c in graph.get_targets(b, type="IS_A"):
            if not graph.has_edge(a, c, "IS_A"):
                new_relations.append({
                    "source": a,
                    "target": c,
                    "type": "IS_A",
                    "confidence": 0.8,
                    "source": "inference"
                })
    
    # 対称性による推論
    # A SIMILAR_TO B なら B SIMILAR_TO A
    for a, b in graph.get_edges(type="SIMILAR_TO"):
        if not graph.has_edge(b, a, "SIMILAR_TO"):
            new_relations.append({
                "source": b,
                "target": a,
                "type": "SIMILAR_TO",
                "weight": graph.get_edge_weight(a, b),
                "source": "inference"
            })
    
    return new_relations
```

### 7.3 可視化例

```python
import networkx as nx
from pyvis.network import Network

def visualize_subgraph(center_term, depth=2):
    # 中心ノードから指定深さまでのサブグラフを抽出
    subgraph = graph.get_subgraph(center_term, depth)
    
    # NetworkXグラフの構築
    G = nx.DiGraph()
    for node in subgraph.nodes:
        G.add_node(node.id, 
                   label=node.term,
                   title=node.definition,
                   color=get_color_by_type(node.type))
    
    for edge in subgraph.edges:
        G.add_edge(edge.source, edge.target,
                   label=edge.type,
                   weight=edge.weight)
    
    # Pyvisで可視化
    net = Network(height="750px", width="100%", directed=True)
    net.from_nx(G)
    net.barnes_hut(gravity=-80000, central_gravity=0.3, spring_length=250)
    
    return net.generate_html()
```

## 8. 評価指標

### 8.1 グラフ品質
- ノード数とエッジ数の比率
- 連結成分の数
- 平均次数
- クラスタリング係数

### 8.2 関係抽出精度
- Precision: 正しく抽出された関係の割合
- Recall: 存在する関係のうち抽出できた割合
- F1スコア

### 8.3 クエリ拡張効果
- 検索精度の向上率
- カバレッジの増加率
- ユーザー満足度

## 9. リスクと対策

| リスク | 影響 | 対策 |
|--------|------|------|
| 誤った関係の抽出 | 検索精度の低下 | 信頼度スコアによるフィルタリング |
| グラフの肥大化 | パフォーマンス低下 | 重要度による枝刈り、インデックス最適化 |
| 循環参照 | 推論の無限ループ | 深さ制限、訪問済みノードの管理 |
| 矛盾する関係 | 知識の不整合 | 一貫性チェック、優先度ルール |

## 10. 今後の拡張可能性

- Neo4jなどのグラフDBへの移行
- GraphQLによるクエリインターフェース
- 機械学習による関係予測
- 時系列変化の追跡（知識の進化）
- マルチモーダル対応（図表との関連付け）
- 外部知識ベースとの連携（WikiData等）

## 11. 参考文献

- [Knowledge Graphs: Fundamentals, Techniques, and Applications](https://mitpress.mit.edu/9780262045094/)
- [Graph-based Natural Language Processing and Information Retrieval](https://www.cambridge.org/core/books/graphbased-natural-language-processing-and-information-retrieval/52508937F88B5B0E0EC8D87DAD231782)
- [HDBSCAN Documentation](https://hdbscan.readthedocs.io/)
- [NetworkX Documentation](https://networkx.org/documentation/stable/)